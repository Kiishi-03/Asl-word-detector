<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ASL to Words - Live Translator</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; background-color: #2c2c2c; color: white; margin: 0; }
        #container { position: relative; margin-top: 20px; border: 5px solid #555; box-shadow: 0 4px 12px rgba(0,0,0,0.4); border-radius: 8px; overflow: hidden; }
        video { display: block; }
        canvas { position: absolute; top: 0; left: 0; }
        #sentence-box { margin-top: 20px; font-size: 2em; font-weight: bold; background-color: #444; padding: 10px 20px; border-radius: 8px; min-height: 50px; text-align: center;}
        #loading { font-size: 1.5em; }
    </style>
</head>
<body>
    <h1>ASL to Words - Live Translator</h1>
    <p>Hold a sign for a few seconds to type. Show the "del" sign to delete.</p>
    
    <div id="container">
        <video id="video" width="640" height="480" autoplay playsinline></video>
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>
    
    <div id="sentence-box" aria-live="polite"></div>
    <div id="loading">Starting camera...</div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const sentenceBox = document.getElementById('sentence-box');
        const loadingMessage = document.getElementById('loading');

        // State variables for the word-building logic
        let sentence = "";
        let lastStablePrediction = "";
        let predictionStartTime = 0;
        const HOLD_DURATION = 3000; // 3 seconds in milliseconds

        // Start the camera
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => {
                video.srcObject = stream;
                loadingMessage.style.display = 'none';
                // Start processing frames every 500ms (2 times per second)
                setInterval(processFrame, 500);
            })
            .catch(err => {
                console.error("Error accessing camera: ", err);
                loadingMessage.textContent = "Error: Could not access camera.";
            });

        async function processFrame() {
            // Draw the current video frame to the canvas
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            // Get the image data from the canvas
            const imageData = canvas.toDataURL('image/jpeg');

            try {
                // Send the image data to the Flask server
                const response = await fetch('/process_frame', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image_data: imageData })
                });

                const data = await response.json();
                const predictedChar = data.prediction;
                
                // Update the word-building logic
                updateSentence(predictedChar);

            } catch (error) {
                console.error('Error processing frame:', error);
            }
        }

        function updateSentence(prediction) {
            const currentTime = Date.now();

            if (prediction && prediction === lastStablePrediction) {
                if (currentTime - predictionStartTime >= HOLD_DURATION) {
                    if (prediction === 'space') {
                        sentence += " ";
                    } else if (prediction === 'del') {
                        sentence = sentence.slice(0, -1);
                    } else if (prediction !== 'nothing') {
                        sentence += prediction;
                    }
                    // Reset timer to prevent re-typing
                    predictionStartTime = Infinity; 
                }
            } else if (prediction && prediction !== 'nothing') {
                lastStablePrediction = prediction;
                predictionStartTime = currentTime;
            } else {
                lastStablePrediction = "";
                predictionStartTime = Infinity;
            }

            sentenceBox.textContent = sentence || " "; // Display a space if empty for layout
        }
    </script>
</body>
</html>
